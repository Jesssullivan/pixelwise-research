"""Bridge nix2container outputs to Bazel.

nix2container builds OCI images declaratively in Nix. This rule builds the image
and exports it as a tarball that can be loaded into container runtimes or pushed
to registries.

Architecture:
    flake.nix (nix2container.buildImage) → nix_oci_image (repo rule) → tarball

The nix2container output is a script that streams the image. We run it with
copyTo to create a docker-archive tarball that can be used by skopeo, podman, etc.
"""

def _nix_oci_image_impl(rctx):
    """Repository rule to build nix2container image and export as tarball.

    nix2container's buildImage produces a script that can stream the image in
    various formats. We use `copyTo docker-archive:` to create a tarball.
    """

    # First, build the nix2container image derivation
    build_result = rctx.execute(
        [
            "nix",
            "build",
            "--no-link",
            "--print-out-paths",
            rctx.attr.flake_ref + "#" + rctx.attr.flake_output,
        ],
        environment = {
            "NIX_CONFIG": "experimental-features = nix-command flakes",
        },
        quiet = False,
        timeout = 600,  # 10 minutes for large builds
    )

    if build_result.return_code != 0:
        fail("nix build failed for {}: {}".format(
            rctx.attr.flake_output,
            build_result.stderr,
        ))

    image_script = build_result.stdout.strip()

    if not image_script:
        fail("nix build returned empty path for {}".format(rctx.attr.flake_output))

    # Create the tarball by running the nix2container copyTo command
    tarball_path = "image.tar"

    # nix2container images have a copyTo script that can export to docker-archive format
    # The script is at $out/bin/copyTo or just $out (if the derivation is the script itself)
    copy_script = image_script + "/bin/copyTo"

    # Check if copyTo exists
    check_result = rctx.execute(["test", "-x", copy_script], quiet = True)

    if check_result.return_code == 0:
        # Use copyTo directly
        copy_result = rctx.execute(
            [copy_script, "docker-archive:" + tarball_path],
            quiet = False,
            timeout = 300,  # 5 minutes for copy
        )
    else:
        # Try the image_script directly (it might be the copyTo script)
        copy_result = rctx.execute(
            [image_script, "docker-archive:" + tarball_path],
            quiet = False,
            timeout = 300,
        )

    if copy_result.return_code != 0:
        # Fallback: try using skopeo to copy from the nix2container directory format
        skopeo_result = rctx.execute(
            [
                "skopeo",
                "copy",
                "--insecure-policy",
                "nix:" + image_script,
                "docker-archive:" + tarball_path,
            ],
            quiet = False,
            timeout = 300,
        )

        if skopeo_result.return_code != 0:
            # Last fallback: the image might be a directory we can reference directly
            rctx.symlink(image_script, "image_dir")
            rctx.file("BUILD.bazel", """\
# AUTO-GENERATED by nix_oci_image repository rule
# Fallback mode: nix2container directory reference
# The copyTo script was not available, exposing raw directory

package(default_visibility = ["//visibility:public"])

filegroup(
    name = "image_dir",
    srcs = glob(["image_dir/**"]),
)

alias(
    name = "image",
    actual = ":image_dir",
)
""")
            return

    # Create BUILD file exposing the tarball
    rctx.file("BUILD.bazel", """\
# AUTO-GENERATED by nix_oci_image repository rule
# DO NOT EDIT - changes will be overwritten

package(default_visibility = ["//visibility:public"])

# The nix2container image as a docker-archive tarball
# Can be loaded with: podman load < image.tar
# Can be pushed with: skopeo copy docker-archive:image.tar docker://registry/image:tag
filegroup(
    name = "tarball",
    srcs = ["image.tar"],
)

# Alias for convenient reference
alias(
    name = "image",
    actual = ":tarball",
)
""")

nix_oci_image = repository_rule(
    implementation = _nix_oci_image_impl,
    attrs = {
        "flake_ref": attr.string(
            default = ".",
            doc = "Flake reference (default: current directory)",
        ),
        "flake_output": attr.string(
            mandatory = True,
            doc = "Flake output name (e.g., 'container-dev')",
        ),
    },
    environ = ["PATH", "HOME", "NIX_CONFIG", "NIX_PATH"],
    local = True,  # Not hermetic, depends on Nix
    doc = """Repository rule that builds a nix2container image and exports it as a tarball.

This bridges nix2container's declarative container definitions to Bazel, enabling
the unified build pipeline: just → bazel → nix2container.

The rule builds the nix2container image and exports it as a docker-archive tarball
that can be loaded into container runtimes or pushed to registries.

Example:
    nix_oci_image(
        name = "nix2container_dev",
        flake_output = "container-dev",
    )

    # In BUILD files, reference the tarball:
    sh_binary(
        name = "load_dev",
        srcs = ["load.sh"],
        data = ["@nix2container_dev//:tarball"],
    )
""",
)
